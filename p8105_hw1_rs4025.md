p8105\_hw1\_rs4025
================
Rebecca Silva
9/12/2019

# Problem 1

``` r
#load packages
library(tidyverse)

#create data frame
df1 = tibble(
  norm_samp = rnorm(8),
  norm_samp_log = norm_samp > 0,
  char_var = as.character(norm_samp), 
  factor_var =  factor( c( "grp1", "grp2", "grp3", "grp3", "grp2", "grp1", "grp2", "grp3" ))
)

#try taking mean of each var
mean(pull (df1, norm_samp))
```

    ## [1] 0.107125

``` r
mean(pull (df1, norm_samp_log))
```

    ## [1] 0.375

``` r
mean(pull (df1, char_var))
```

    ## Warning in mean.default(pull(df1, char_var)): argument is not numeric or
    ## logical: returning NA

    ## [1] NA

``` r
mean(pull (df1, factor_var))
```

    ## Warning in mean.default(pull(df1, factor_var)): argument is not numeric or
    ## logical: returning NA

    ## [1] NA

When trying to take the mean of each variable before converting, the
output for the character and factor vector are NA’s, and I receive a
warning message. We can obtain a mean for the numeric vector, as it is
numeric, and the logical vector because TRUE and FALSE are converted to
values 1 and 0, respectively, when used in a function.

``` r
#convert vars 
as.numeric(pull (df1, norm_samp_log))
as.numeric(pull (df1, char_var))
as.numeric(pull (df1, factor_var))
```

Using ‘as.numeric’ converts

  - the logicals into integers of 0 (false) and 1 (true).
  - the characters into a numeric value.
  - the factors into the numeric value of their assigned level.

Essentially, the function tries to convert each element of the vector
into a number. Without converting the variables into a number, R is
unable to take the mean, and therefore we get an error.

``` r
#logical to numeric
logical_num = as.numeric(pull (df1, norm_samp_log))
pull( df1, norm_samp) * logical_num
```

    ## [1] 0.0000000 2.7219189 0.0000000 1.1371240 0.0000000 0.0000000 0.0000000
    ## [8] 0.8428201

``` r
#logical to factor
logical_factor = as.factor(pull (df1, norm_samp_log))
pull( df1, norm_samp) * logical_factor #not possible
```

    ## Warning in Ops.factor(pull(df1, norm_samp), logical_factor): '*' not
    ## meaningful for factors

    ## [1] NA NA NA NA NA NA NA NA

``` r
#logical to factor to numeric
logical_factor_num = as.numeric( 
  as.factor( pull (df1, norm_samp_log)))
pull( df1, norm_samp) * logical_factor_num
```

    ## [1] -0.8873105  5.4438378 -0.6498239  2.2742481 -0.8137252 -0.2991471
    ## [7] -1.1948559  1.6856401

Similar to when we were trying to find the mean of a factor variable,
multiplying a numeric variable by a factor variable will no work since
multiplication does not work on anything other than a number.

# Problem 2

``` r
# create dataframe
df2 = tibble(
  x = rnorm(500),
  y = rnorm(500),
  log_var = x + y > 1, 
  num_var = as.numeric(log_var),
  factor_var = as.factor(log_var)
)
```

The data frame, ‘df2’, has 500 rows and 5 columns. The mean of x is
0.062996, the median of x is 0.0728596, and the standard deviation of x
is 0.9903893. The proportion of cases for which \(x+y > 1\) is 0.242.

``` r
# scatter plot 1 - color by logical 
ggplot(df2, aes(x = x, y = y, color = log_var)) + geom_point()
```

![](p8105_hw1_rs4025_files/figure-gfm/unnamed-chunk-4-1.png)<!-- -->

``` r
#export first scatter plot
ggsave("scatter_plot_hw1.pdf", height = 4, width = 6) 

# scatter plot 2 - color by numeric 
ggplot(df2, aes(x = x, y = y, color = num_var)) + geom_point()
```

![](p8105_hw1_rs4025_files/figure-gfm/unnamed-chunk-4-2.png)<!-- -->

``` r
# scatter plot 3 - color by factor 
ggplot(df2, aes(x = x, y = y, color = factor_var)) + geom_point()
```

![](p8105_hw1_rs4025_files/figure-gfm/unnamed-chunk-4-3.png)<!-- -->

The color scales for the factor and logical variables are discrete,
using two colors to represent ‘False’/‘True’ and ‘0’/‘1’, respectively.
The color scale for the numeric vector is continuous; darker hues of
blue indicate values closer to 0 and lighter hues indicate values of the
numeric vector that are closer to 1.
